<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta
            name="apple-mobile-web-app-status-bar-style"
            content="black-translucent"
        />
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
        <link
            href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@200..800&display=swap"
            rel="stylesheet"
        />
        <link rel="apple-touch-icon" href="/sauna_180.png" />
        <title>Is The Sauna Hot?</title>
        <style>
            :root {
                --text-color: #283f43;
                --stroke-color: #a2c6cc;
                --background-color: #eff9fa;
                --subtext-color: rgba(0, 0, 0, 0.5);
                --error-color: #ff5f5f;
            }

            html,
            body {
                height: 100%;
                margin: 0;
                padding: 0;
                font-family: "Plus Jakarta Sans", sans-serif;
                background-color: var(--background-color);
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                overflow: hidden;
            }

            body {
                -webkit-touch-callout: none;
                -webkit-text-size-adjust: none;
                -webkit-overflow-scrolling: touch;
            }

            #content {
                z-index: 1;
                text-align: center;
            }

            #status {
                display: block;
                font-size: calc(1rem + 10vw);
                margin: 8px 0 16px 0;
                font-weight: 500;
                color: var(--text-color);
            }

            #status.isNotShowingTemp {
                visibility: hidden;
            }

            #data-container {
                padding-bottom: 30vh;
            }

            #data {
                font-size: calc(0.5rem + 5vw);
                font-weight: 300;
                color: var(--subtext-color);
                cursor: pointer;
            }

            #data.error {
                white-space: pre-wrap;
                border: 1px solid var(--error-color);
                font-size: calc(0.5rem + 1vw);
                padding: 0.85em 1em 1em;
                border-radius: 0.5em;
            }

            .error {
                color: var(--error-color);
            }

            #loading-indicator {
                width: calc(0.5rem + 4vw);
                height: calc(0.5rem + 4vw);
                padding-left: 1vw;
                display: none;
                position: absolute;
                left: 50%;
                transform: translateX(-50%);
            }

            #loading-indicator circle {
                transition: stroke-dasharray 0.2s ease-in;
            }

            #indicator {
                stroke-dasharray: 150 282.743;
                stroke-dashoffset: 0;
                animation: spin 1s linear infinite;
            }

            @keyframes spin {
                100% {
                    stroke-dashoffset: -282.743;
                }
            }

            #sparkline {
                position: absolute;
                bottom: 0;
                left: 0;
                right: 0;
                width: 100%;
                height: 100vh;
                z-index: 0;
            }
        </style>
    </head>

    </body>
        <div id="content">
            <div id="status"></div>
            <div id="data-container">
                <div id="data">üå´Ô∏è</div>
                <svg id="loading-indicator" viewBox="0 0 100 100">
                    <circle
                        class="circle-background"
                        cx="50"
                        cy="50"
                        r="34"
                        fill="none"
                        stroke="var(--subtext-color)"
                        opacity="0.1"
                        stroke-width="16"
                    />
                    <circle
                        id="indicator"
                        cx="50"
                        cy="50"
                        r="34"
                        fill="none"
                        stroke="var(--stroke-color)"
                        stroke-width="16"
                        stroke-dasharray="0 282.743"
                    />
                </svg>
            </div>
        </div>

        <svg
            id="sparkline"
            viewbox="0 0 600 40"
            preserveaspectratio="none"
            width="100%"
            height="100%"
        ></svg>

        <script>
            let isShowingTemperature = true;
            let temperatureData = [];
            let humidityData = [];
            let mostRecentTemp = 0;
            let mostRecentHumidity = 0;

            function interpolateColor(color1, color2, factor) {
                const result = color1.slice();
                for (let i = 0; i < 3; i++) {
                    result[i] = Math.round(
                        result[i] + factor * (color2[i] - result[i]),
                    );
                }
                return `rgb(${result.join(",")})`;
            }

            function setColors(temperature) {
                const minTemp = 80;
                const maxTemp = 135;

                const minColors = {
                    text: [40, 63, 67],
                    stroke: [162, 198, 204],
                    background: [239, 249, 250],
                };

                const maxColors = {
                    text: [70, 39, 19],
                    stroke: [253, 221, 193],
                    background: [249, 243, 238],
                };

                const factor = (temperature - minTemp) / (maxTemp - minTemp);
                const textColor = interpolateColor(
                    minColors.text,
                    maxColors.text,
                    factor,
                );
                const strokeColor = interpolateColor(
                    minColors.stroke,
                    maxColors.stroke,
                    factor,
                );
                const backgroundColor = interpolateColor(
                    minColors.background,
                    maxColors.background,
                    factor,
                );

                document.documentElement.style.setProperty(
                    "--text-color",
                    textColor,
                );
                document.documentElement.style.setProperty(
                    "--stroke-color",
                    strokeColor,
                );
                document.documentElement.style.setProperty(
                    "--background-color",
                    backgroundColor,
                );
            }

            async function fetchData() {
                const loadingIndicator =
                    document.getElementById("loading-indicator");
                loadingIndicator.style.display = "block";

                try {
                    const currentDate = new Date().toISOString().slice(0, 10); // Get date in YYYY-MM-DD format
                    let data = await fetchDataForDate(currentDate);

                    if (!data || !hasEnoughHoursOfData(data, 3)) { // If less than 3 hours of data
                        const previousDate = new Date();
                        previousDate.setDate(previousDate.getDate() - 1);
                        const previousDateString = previousDate.toISOString().slice(0, 10);
                        const previousData = await fetchDataForDate(previousDateString);

                        data = [...previousData, ...data];
                    }

                    processData(data, 3);

                    loadingIndicator.style.display = "none";
                    document.getElementById("data").classList.remove("error");
                } catch (error) {
                    console.error("Error fetching data:", error);
                    document.getElementById("data").textContent =
                        "Error fetching data";
                    document.getElementById("data").classList.add("error");
                    loadingIndicator.style.display = "none";
                }
            }

            async function fetchDataForDate(date) {
                const response = await fetch(
                    `https://jolly-hall-8315.fbkfp5vygk.workers.dev/LHT65%20Temperature%20Sensor?date=${date}`,
                );
                return await response.json();
            }

            function hasEnoughHoursOfData(data, hours) {
                if (data.length === 0) return false;

                const firstTimestamp = new Date(data[0].timestamp).getTime();
                const lastTimestamp = new Date(data[data.length - 1].timestamp).getTime();
                const hoursInMillis = hours * 60 * 60 * 1000;

                return (lastTimestamp - firstTimestamp) >= hoursInMillis;
            }

            function processData(data, hours) {
                if (data.length === 0) return;

                // Extracting the most recent hours of values
                const recentData = [];
                const hoursInMillis = hours * 60 * 60 * 1000;
                const now = new Date().getTime();

                for (let i = data.length - 1; i >= 0; i--) {
                    const timestamp = new Date(data[i].timestamp).getTime();
                    if (now - timestamp <= hoursInMillis) {
                        recentData.unshift(data[i]);
                    } else {
                        break;
                    }
                }

                temperatureData = recentData
                    .filter((entry) => entry.data?.TempC_SHT !== undefined)
                    .map((entry) => entry.data.TempC_SHT);
                humidityData = recentData
                    .filter((entry) => entry.data?.Hum_SHT !== undefined)
                    .map((entry) => entry.data.Hum_SHT);

                mostRecentTemp = Math.round(
                    (temperatureData[temperatureData.length - 1] * 9) / 5 + 32,
                );
                mostRecentHumidity = Math.round(
                    humidityData[humidityData.length - 1],
                );

                document.getElementById("data").textContent =
                    `${mostRecentTemp}¬∞F`;

                // Set state of the Sauna
                let readyOrNot = "";
                if (mostRecentTemp < 80) {
                    readyOrNot = "Nope";
                    setColors(80);
                } else if (mostRecentTemp < 135) {
                    readyOrNot = "Getting There";
                    setColors(mostRecentTemp);
                } else {
                    // 135+
                    readyOrNot = "Yes!";
                    setColors(135);
                }
                document.getElementById("status").textContent = readyOrNot;

                drawSparkline(temperatureData);
            }

            function drawSparkline(data) {
                const svg = document.getElementById("sparkline");
                const width = 600;
                const height = 40;
                const maxValue = 100;
                const minValue = 0;
                const padding = 0;
                const step = (width - 2 * padding) / (data.length - 1);

                svg.innerHTML = "";

                const points = data.map((value, index) => {
                    const x = padding + index * step;
                    const y =
                        height -
                        padding -
                        ((value - minValue) * (height - 2 * padding)) /
                            (maxValue - minValue);
                    return [x, y];
                });

                const tangents = calculateTangents(points);
                let lineD = `M ${points[0][0]},${points[0][1]}`;
                let polygonD = `M ${points[0][0]},${points[0][1]}`;

                for (let i = 0; i < points.length - 1; i++) {
                    const [p1, p2] = [points[i], points[i + 1]];
                    const [t1, t2] = [tangents[i], tangents[i + 1]];
                    const cp1 = [p1[0] + t1[0] / 3, p1[1] + t1[1] / 3];
                    const cp2 = [p2[0] - t2[0] / 3, p2[1] - t2[1] / 3];
                    lineD += ` C ${cp1[0]},${cp1[1]} ${cp2[0]},${cp2[1]} ${p2[0]},${p2[1]}`;
                    polygonD += ` C ${cp1[0]},${cp1[1]} ${cp2[0]},${cp2[1]} ${p2[0]},${p2[1]}`;
                }

                polygonD += ` L ${points[points.length - 1][0]},${height} L ${points[0][0]},${height} Z`;

                const polygon = document.createElementNS(
                    "http://www.w3.org/2000/svg",
                    "path",
                );
                polygon.setAttribute("fill", "var(--stroke-color)");
                polygon.setAttribute("stroke", "none");
                polygon.setAttribute("d", polygonD);
                svg.appendChild(polygon);

                const path = document.createElementNS(
                    "http://www.w3.org/2000/svg",
                    "path",
                );
                path.setAttribute("fill", "none");
                path.setAttribute("stroke", "var(--text-color)");
                path.setAttribute("stroke-width", "6");
                path.setAttribute("stroke-linecap", "round");
                path.setAttribute("vector-effect", "non-scaling-stroke");
                path.setAttribute("d", lineD);
                svg.appendChild(path);
            }

            function calculateTangents(points) {
                const tangents = [];
                for (let i = 0; i < points.length; i++) {
                    const p0 = points[i - 1] || points[i];
                    const p1 = points[i + 1] || points[i];
                    const tangent = [(p1[0] - p0[0]) / 2, (p1[1] - p0[1]) / 2];
                    tangents.push(tangent);
                }
                return tangents;
            }

            function toggleData() {
                isShowingTemperature = !isShowingTemperature;
                const dataElement = document.getElementById("data");
                if (isShowingTemperature) {
                    document
                        .getElementById("status")
                        .classList.remove("isNotShowingTemp");
                    dataElement.textContent = `${mostRecentTemp}¬∞F`;
                    drawSparkline(temperatureData);
                } else {
                    document
                        .getElementById("status")
                        .classList.add("isNotShowingTemp");
                    dataElement.textContent = `${mostRecentHumidity}%`;
                    drawSparkline(humidityData);
                }
            }

            function startFetching() {
                fetchData();
                setInterval(fetchData, 300000); // Fetch data every 5 min (300000 ms)
            }

            document.addEventListener("visibilitychange", () => {
                if (document.visibilityState === "visible") {
                    fetchData(); // Fetch data when the user returns to the tab
                }
            });

            document.addEventListener("DOMContentLoaded", () => {
                startFetching();
            });

            document
                .getElementById("data")
                .addEventListener("click", toggleData);
        </script>
    </body>
</html>
